/****^  ***********************************************************
        *                                                         *
        * Copyright, (C) Honeywell Bull Inc., 1988                *
        *                                                         *
        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        *                                                         *
        * Copyright (c) 1972 by Massachusetts Institute of        *
        * Technology and Honeywell Information Systems, Inc.      *
        *                                                         *
        *********************************************************** */




/****^  HISTORY COMMENTS:
  1) change(86-09-30,Oke), approve(86-09-30,MCR7543), audit(86-09-30,JRGray),
     install(86-10-08,MR12.0-1180):
     Allow ALM to support double word constants.
  2) change(86-10-01,JRGray), approve(86-10-01,MCR7507),
     audit(86-10-27,RWaters), install(86-11-12,MR12.0-1202):
     Modified to support severity, *heap references, the "init_link" pseudo,
     and joining to the symbol section.
  3) change(86-11-14,JRGray), approve(86-11-14,MCR7568),
     audit(86-11-21,RWaters), install(86-11-26,MR12.0-1228):
     Also MCR7572. Modified to add support for the three new pseudo-ops: ext_entry,
     oct_unal, and dec_unal.
  4) change(88-03-21,JRGray), approve(88-08-05,MCR7952),
     audit(88-09-30,WAAnderson), install(88-10-17,MR12.2-1169):
     Changed for symbol table support. Add labels for 12 new pseudos that are
     ignored in pass1.
                                                   END HISTORY COMMENTS */


pass1_: 
     procedure(decor,target_value,no_target_given,first_time_thru); /* decor is initialized and passed from alm_6180_ ; 
					     target_value, no_target_given come from alm_ via alm_6180_ */

		/* 
		   pass1 is the first pass of the Multics assembler .

		   pass1 is primarily concerned with assigning symbol definitions
		   so that pass2 of the assembler can generate the binary output.
		   pass1 causes several tables to be generated and maintained,
		   including the assignment table (for internal symbols) and
		   the external name table, segment name table, trap word
		   table, link table, literal table, etc. no collation tape
		   is written, but the pc at the end of each statement is
		   recorded in a list for comparison in pass2, any discrepancy
		   is a phase error.
		   multiple location counters added
		   by J. D. Mills, 1 June 1967.


	Modified to support *heap links by R Gray and W Anderson on 2/05/86.
	Modified for changes to decor processing requested by MTR 175  on 3/25/81 by EBush.
	Modified to implement -target on 2/5/81 by EBush.
	Modified for decor processing 12/30/80 by E Bush
	Modified for macro processing 3/23/77 by Noel I. Morris
          Modified for prelinking on 06/15/75 by Eugene E Wiatrowski
	Modified 740905 by PG and ARD to extend ACC/ACI/BCI to 167/168/252 characters.
	Modified on 07/28/73 at 23:48:28 by R F Mabee.
	by RFM in June 1973 to add EIS instructions including multi-word operands.
	by RFM on 9 November 1972 to avoid reserving space for text entry sequence in old object format.
	by RFM on 21 July 1972 to fix R error on call to internal symbol.
	by RFM on 21 March 1972 for new object segment format.
	by RFM on 4 March to add new call/save/return operators.
	by RHG on 2 June 1971 to suppress "N" flag for undefined op code (should be "O")
	by RHG on 2 April 1971 to make rem=null if there was a label
			   to allow "bss ,exp" with no label specified
	by RHG on 17 Sept 1970 for new listing package
	by RHG on 7 August 1970 at 0545 for new sthead (name pseudo-op)
	by NA on July 14, 1970 at 1710 for the proper use of search_return
			and to call expevl_ as a function not a regular subroutine
		    */

/* "Common" variables initialized in eb_data_ */


%include varcom;
%include concom;
%include erflgs;
%include codtab;
%include sthedr;
%include mxpro;
%include lstcom;
%include labarg;
%include alm_lc;
%include alm_options;
%include alm_data;
/**/
/* EXTERNAL ENTRIES CALLED BY PASS1 */

 dcl		getid_		ext entry,
		getid_$getnam	ext entry,
		inputs_$next	ext entry,
		inputs_$next_statement	ext entry,
		inputs_$nxtnb	ext entry,
		utils_$pckflg	ext entry ( fixed bin (26) ),
		alm_include_file_$pass1 ext entry,
		alm_include_file_$insert ext entry (ptr, fixed bin (26), fixed bin (26)),
		alm_include_file_$pop ext entry,
		inputs_$get_ptr ext entry (ptr, fixed bin (26), fixed bin (26), bit (1) aligned),
		mexp_		ext entry (char (*), fixed bin (26), fixed bin(17), bit(1), bit(1)),
		mexp_$define_macro	ext entry (char (*)),
		oplook_$reset	ext entry,
		oplook_$redefine	ext entry,
		getid_$setid	ext entry ( fixed bin (26)),
		glpl_$slwrd	ext entry ( fixed bin (26), fixed bin (26), fixed bin (26)),
		glpl_$storl	ext entry ( fixed bin (26), fixed bin (26)),
		glpl_$storr	ext entry ( fixed bin (26), fixed bin (26)),
		system_type_	ext entry ( char(*), char(*), fixed bin, fixed bin(35));

/* EXTERNAL FUNCTIONS CALLED BY PASS1 */

 dcl	(	ascevl_$accevl	ext entry (fixed bin (26)),
		ascevl_$acievl	ext entry (fixed bin (26)),
		ascevl_$ac4evl	ext entry (fixed bin (26)),
		ascevl_$bcdevl	ext entry (fixed bin (26)),
		expevl_		ext entry ( fixed bin (26), fixed bin (26), fixed bin (26)),
		lstman_$blkasn	ext entry ( fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26)),
		glpl_$cwrd	ext entry ( fixed bin (26)),
		glpl_$glwrd	ext entry ( fixed bin (26), fixed bin(26)),
		decevl_		ext entry ( fixed bin (26), fixed bin (26))) returns (fixed bin (26));
dcl	(	utils_$exadrs	ext entry ( fixed bin (26), fixed bin (26)),
		lstman_$lnkasn	ext entry ( fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26)),
		lstman_$outasn	ext entry ( fixed bin (26), fixed bin (26), fixed bin (26)),
		utils_$ls ext entry (fixed bin (26), fixed bin (26)),
		utils_$rs		ext entry ( fixed bin (26), fixed bin (26)),
		lstman_$namasn	ext entry ( fixed bin (26)),
		utils_$nswrds	ext entry ( fixed bin )) returns (fixed bin (26));
dcl	(	octevl_		ext entry ( fixed bin (26)),
		oplook_$oplook_	ext entry ( fixed bin (26), fixed bin (26)),
		glpl_$setblk	ext entry ( fixed bin (26), fixed bin (26) ),
		table_		ext entry ( fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26),
					  fixed bin (26)),
		lstman_$trpasn	ext entry ( fixed bin (26), fixed bin (26)),
		varevl_		ext entry ( fixed bin (26), fixed bin (26), fixed bin (26), fixed bin (26),
					  fixed bin (26), fixed bin (26)),
		vfdevl_$vfdcnt	ext entry ( fixed bin (26), fixed bin (26))
			) returns ( fixed bin (26));



/* AUTOMATIC VARIABLES USED BY PASS1 */
 dcl	(binop, flags, i, iaddr, iflag, itype, iwhat, j, junk, k, link, mul, n, newrho, nwrds, option,
	basno, value, b29, admod, pcblk (3), class, type, xnlnk, ptrcal, ptrarg, trplnk, blklnk, symlnk,
	rslts (42), newval, oldval, tbss, tderr, stat_or_link ) fixed bin (26);
dcl	label_flag	bit (1) aligned;
dcl	end_statement_flag 	bit (1) aligned;
dcl	dup_ptr ptr init (null ()),
	temp_ptr ptr,
	dup_count fixed bin (26),
	dup_start fixed bin (26),
	dup_string (0:262143) char (1) unal based (dup_ptr);
dcl       operand    char(32) varying;
dcl	canonical_operand char(24);
dcl	code	fixed bin(35);
dcl	(stkclst, stkctop) fixed bin(26);		/* used to remember stackframe sizes */
dcl	ext_entry_count fixed bin;
dcl	remember_sym(8) fixed bin(26);	/* used to remember sym */

/* LABEL VARIABLE */
 dcl	search_return label local;

 dcl	static_in_linkage bit(1) initial("0"b);
 


 

/* EXTERNAL DATA USED BY PASS1 */
 dcl	(eb_data_$itext, eb_data_$ilink, eb_data_$isym, eb_data_$istatic, eb_data_$idefs, eb_data_$ioff, eb_data_$ion,
	eb_data_$nertls, eb_data_$nmxcal, eb_data_$nmxclb, eb_data_$nmxsav, eb_data_$nretls,
	eb_data_$nslcal, eb_data_$nslsav,
	eb_data_$new_nslcal, eb_data_$new_nslsav, eb_data_$new_nretls, eb_data_$short_nretls,
	eb_data_$new_nentls, eb_data_$short_nslcal, eb_data_$new_ngetlp,
	eb_data_$atext2 (2), eb_data_$alink2 (2), eb_data_$asym2 (2), eb_data_$astatic2 (2), eb_data_$asystem2 (2),
	eb_data_$adef2 (2),
	eb_data_$tsym, eb_data_$atext (2), eb_data_$alink (2), eb_data_$asym (2), eb_data_$asys (2), eb_data_$aheap(2),
	eb_data_$astat (2)) ext fixed bin (26);

 dcl	eb_data_$separate_static ext bit(1);
dcl	eb_data_$entrybound_bit ext bit(1);
dcl	eb_data_$macro_depth fixed bin (26) ext;


/* PARAMETERS */

dcl       decor fixed bin(35); /* passed from alm_6180_ */
dcl	target_value fixed bin(17); /* ditto */
dcl	(no_target_given,first_time_thru) bit(1); /* likewise */



/* OVERLAY FOR SETTING HALF WORDS */

 dcl	1 word based aligned,
	  2 (left,right) bit (18) unaligned;

 dcl	1 glpl_words (0:262143) based (eb_data_$lavptr) aligned,
	  2 left bit (18) unaligned,
	  2 right bit (18) unaligned;

 dcl	1 acc aligned based,
	  2 length bit (9) unaligned,
	  2 string char (32) unaligned;

 dcl	eb_data_$lavptr external pointer;
 dcl	eb_data_$per_process_static_sw fixed bin external;



/* entry to subroutine, set up variables before main loop. */


label_100: 
	pc = 0;
	labarg = 0;
	tfirstreftrap = 0;
	ext_entry_count = 0;
	eb_data_$separate_static,
	eb_data_$entrybound_bit,
	static_in_linkage = "0"b;
 
 

/* Initialize system location counters. */

	junk = table_ (iassgn, lctext (1), 0, fmlcrf, iaddr);
	ulclst, ulcend, curlc, lptext = iaddr;

	junk = table_ (iassgn, lcst (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr+2, ulclst);
	call glpl_$storl (ulclst+2, iaddr);
	ulclst, lpst = iaddr;
	call glpl_$storr (lpst+4, eb_data_$isym);

	junk = table_ (iassgn, lcdefs (1), 0, fmlcrf, iaddr);
	tlclst, dlclst, lpdefs = iaddr;

	junk = table_ (iassgn, lclit (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr+2, tlclst);
	call glpl_$storl (tlclst+2, iaddr);
	tlclst, lplit = iaddr;
	call glpl_$storl (lplit+4, 2);

	junk = table_ (iassgn, lcentries (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr + 2, tlclst);
	call glpl_$storl (tlclst + 2, iaddr);
	tlclst, lpentries = iaddr;

	junk = table_ (iassgn, lccall (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr+2, tlclst);
	call glpl_$storl (tlclst+2, iaddr);
	tlclst, lpcall = iaddr;

	junk = table_ (iassgn, lctv (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr+2, tlclst);
	call glpl_$storl (tlclst+2, iaddr);
	tlclst, lptv = iaddr;

	junk = table_ (iassgn, lcsect (1), 0, fmlcrf, iaddr);
	llclst, lpsect = iaddr;
	call glpl_$slwrd (lpsect+4, 2, eb_data_$ilink);

	junk = table_ (iassgn, lchead (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr+2, llclst);
	call glpl_$storl (llclst+2, iaddr);
	llclst, lphead = iaddr;
	call glpl_$storr (lphead+4, eb_data_$ilink);

	junk = table_ (iassgn, lcrst (1), 0, fmlcrf, iaddr);
	slclst, lprst = iaddr;
	call glpl_$storr (lprst+4, eb_data_$isym);

	junk = table_ (iassgn, lcrlk (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr+2, slclst);
	call glpl_$storl (slclst+2, iaddr);
	slclst, lprlk = iaddr;
	call glpl_$storr (lprlk+4, eb_data_$isym);

	junk = table_ (iassgn, lcrtx (1), 0, fmlcrf, iaddr);
	call glpl_$storr (iaddr+2, slclst);
	call glpl_$storl (slclst+2, iaddr);
	slclst, lprtx = iaddr;
	call glpl_$storr (lprtx+4, eb_data_$isym);

	/* make stackframe_size list */
	stkctop = glpl_$setblk(0, 1);
	stkclst = stkctop;

	binlin = 1;
	call oplook_$reset;

/* main loop re-entry, assign any symbols in location field. */

label_200: 
	label_flag = "0"b;
label_210:
	spc = pc;
	brk (1) = isp;
	call getid_;
	if (brk (1) ^= icol) then goto label_300;
	if (eb_data_$tsym ^= 0) then junk = table_ (iassgn,sym (1),spc,flocrf,curlc);
	label_flag = "1"b;
	goto label_210;

/* get operator and test for pseudo-operation. */

label_300: 
	if sym (1) ^= 0 then goto label_302;
	if brk (1) = inl then goto label_870;
	if brk (1) = iquot then goto label_870;
label_302:
	binop = oplook_$oplook_ ( iflag, itype );
	if iflag ^= 0 then do;
	     call mexp_ (substr (addr (sym (1)) -> acc.string, 1, bin (addr (sym (1)) -> acc.length, 9)), iflag, target_value, no_target_given,first_time_thru);
	     if iflag ^= 0 then go to label_3200;
	     else go to label_3030;
	end;
	if (brk (1) = isp /*iht ditto*/	|	brk (1) =inl /* icr and isc ditto*/ )  then goto label_305;

/* then there is an error in this sta